const ConstructionService = require('../../application/services/construction-service');
const ResponseHelper = require('../../shared/utils/response-helper');

class ConstructionController {
    constructor() {
        this.constructionService = new ConstructionService();
    }

    /**
     * Listar constru√ß√µes dispon√≠veis
     */
    async getAvailableConstructions(req, res) {
        try {
            console.log('üèóÔ∏è [CONTROLLER] Listando constru√ß√µes dispon√≠veis');
            
            const filters = req.query;
            const constructions = await this.constructionService.getAvailableConstructions(filters);
            
            return ResponseHelper.success(res, {
                constructions,
                total: constructions.length,
                message: 'Constru√ß√µes dispon√≠veis listadas com sucesso'
            });

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao listar constru√ß√µes:', error);
            return ResponseHelper.error(res, 'Erro ao listar constru√ß√µes dispon√≠veis', 500);
        }
    }

    /**
     * Verificar se pode iniciar constru√ß√£o
     */
    async canStartConstruction(req, res) {
        try {
            console.log('üîç [CONTROLLER] Verificando possibilidade de iniciar constru√ß√£o');
            
            // CORRE√á√ÉO: Validar se user existe
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            const userId = req.user.id;
            const { constructionTypeId } = req.params;

            // CORRE√á√ÉO: Validar par√¢metros
            if (!constructionTypeId) {
                return ResponseHelper.badRequest(res, 'ID do tipo de constru√ß√£o √© obrigat√≥rio');
            }
            
            const canStart = await this.constructionService.canStartConstruction(userId, constructionTypeId);
            
            return ResponseHelper.success(res, canStart);

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao verificar constru√ß√£o:', error);
            return ResponseHelper.error(res, 'Erro ao verificar possibilidade de constru√ß√£o', 500);
        }
    }

    /**
     * Iniciar nova constru√ß√£o
     */
    async startConstruction(req, res) {
        try {
            console.log('üöÄ [CONTROLLER] Iniciando nova constru√ß√£o');
            
            // CORRE√á√ÉO: Validar autentica√ß√£o
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            const userId = req.user.id;
            const { construction_type_id } = req.body;

            // CORRE√á√ÉO: Validar dados do body
            if (!construction_type_id) {
                return ResponseHelper.badRequest(res, 'ID do tipo de constru√ß√£o √© obrigat√≥rio');
            }
            
            const result = await this.constructionService.startConstruction(userId, construction_type_id);
            
            return ResponseHelper.success(res, result, 201);

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao iniciar constru√ß√£o:', error);
            
            if (error.message.includes('insuficiente') || error.message.includes('Necess√°rio') || error.message.includes('Limite')) {
                return ResponseHelper.badRequest(res, error.message);
            }

            if (error.message.includes('n√£o encontrado')) {
                return ResponseHelper.notFound(res, error.message);
            }
            
            return ResponseHelper.error(res, 'Erro ao iniciar constru√ß√£o', 500);
        }
    }

    /**
     * Selecionar empresa vencedora da licita√ß√£o
     */
    async selectBiddingWinner(req, res) {
        try {
            console.log('üèÜ [CONTROLLER] Selecionando vencedora da licita√ß√£o');
            
            // CORRE√á√ÉO: Validar autentica√ß√£o
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            const userId = req.user.id;
            const { constructionId } = req.params;
            const { company_index, reason } = req.body;

            // CORRE√á√ÉO: Validar par√¢metros obrigat√≥rios
            if (!constructionId) {
                return ResponseHelper.badRequest(res, 'ID da constru√ß√£o √© obrigat√≥rio');
            }

            if (company_index === undefined || company_index === null) {
                return ResponseHelper.badRequest(res, '√çndice da empresa √© obrigat√≥rio');
            }
            
            const result = await this.constructionService.selectBiddingWinner(
                userId, 
                constructionId, 
                company_index, 
                reason
            );
            
            return ResponseHelper.success(res, result);

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao selecionar vencedora:', error);
            
            if (error.message.includes('n√£o encontrada') || error.message.includes('n√£o existe')) {
                return ResponseHelper.notFound(res, error.message);
            }

            if (error.message.includes('inv√°lido') || error.message.includes('licita√ß√£o')) {
                return ResponseHelper.badRequest(res, error.message);
            }
            
            return ResponseHelper.error(res, 'Erro ao selecionar empresa vencedora', 500);
        }
    }

    /**
     * Listar constru√ß√µes do usu√°rio
     */
    async getUserConstructions(req, res) {
        try {
            console.log('üìã [CONTROLLER] Listando constru√ß√µes do usu√°rio');
            
            // CORRE√á√ÉO: Validar autentica√ß√£o
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            const userId = req.user.id;
            const filters = req.query;
            
            const constructions = await this.constructionService.getUserConstructions(userId, filters);
            
            return ResponseHelper.success(res, {
                constructions,
                total: constructions.length,
                summary: this.generateConstructionsSummary(constructions),
                message: 'Constru√ß√µes do usu√°rio listadas com sucesso'
            });

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao listar constru√ß√µes do usu√°rio:', error);
            return ResponseHelper.error(res, 'Erro ao listar constru√ß√µes do usu√°rio', 500);
        }
    }

    /**
     * Obter detalhes de uma constru√ß√£o espec√≠fica
     */
    async getConstructionById(req, res) {
        try {
            console.log('üîç [CONTROLLER] Buscando detalhes da constru√ß√£o');
            
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            const userId = req.user.id;
            const { constructionId } = req.params;

            if (!constructionId) {
                return ResponseHelper.badRequest(res, 'ID da constru√ß√£o √© obrigat√≥rio');
            }

            const construction = await this.constructionService.getConstructionById(userId, constructionId);
            
            return ResponseHelper.success(res, construction);

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao buscar constru√ß√£o:', error);
            
            if (error.message.includes('n√£o encontrada')) {
                return ResponseHelper.notFound(res, error.message);
            }
            
            return ResponseHelper.error(res, 'Erro ao buscar detalhes da constru√ß√£o', 500);
        }
    }

    /**
     * Obter hist√≥rico de constru√ß√µes completadas
     */
    async getConstructionHistory(req, res) {
        try {
            console.log('üìö [CONTROLLER] Buscando hist√≥rico de constru√ß√µes');
            
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            const userId = req.user.id;
            const filters = { ...req.query, status: 'completed' };
            
            const history = await this.constructionService.getUserConstructions(userId, filters);
            
            return ResponseHelper.success(res, {
                history,
                total: history.length,
                message: 'Hist√≥rico de constru√ß√µes obtido com sucesso'
            });

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao buscar hist√≥rico:', error);
            return ResponseHelper.error(res, 'Erro ao buscar hist√≥rico de constru√ß√µes', 500);
        }
    }

    /**
     * Cancelar constru√ß√£o
     */
    async cancelConstruction(req, res) {
        try {
            console.log('üõë [CONTROLLER] Cancelando constru√ß√£o');
            
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            const userId = req.user.id;
            const { constructionId } = req.params;
            const { reason } = req.body;

            if (!constructionId) {
                return ResponseHelper.badRequest(res, 'ID da constru√ß√£o √© obrigat√≥rio');
            }
            
            const result = await this.constructionService.cancelConstruction(userId, constructionId, reason);
            
            return ResponseHelper.success(res, result);

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao cancelar constru√ß√£o:', error);
            
            if (error.message.includes('n√£o encontrada')) {
                return ResponseHelper.notFound(res, error.message);
            }

            if (error.message.includes('Apenas') || error.message.includes('licita√ß√£o')) {
                return ResponseHelper.badRequest(res, error.message);
            }
            
            return ResponseHelper.error(res, 'Erro ao cancelar constru√ß√£o', 500);
        }
    }

    /**
     * NOVO: For√ßar atualiza√ß√£o de constru√ß√µes (Admin)
     */
    async forceConstructionUpdate(req, res) {
        try {
            console.log('üîß [CONTROLLER] For√ßando atualiza√ß√£o de constru√ß√µes (Admin)');
            
            if (!req.user || !req.user.id) {
                return ResponseHelper.unauthorized(res, 'Usu√°rio n√£o autenticado');
            }

            // Verificar se √© admin (pode adicionar essa valida√ß√£o se necess√°rio)
            // if (!req.user.is_admin) {
            //     return ResponseHelper.forbidden(res, 'Acesso negado - apenas administradores');
            // }

            // Executar verifica√ß√£o de integridade dos dados
            const integrityCheck = await this.constructionService.checkDataIntegrity(req.user.id);
            
            return ResponseHelper.success(res, {
                message: 'Verifica√ß√£o de integridade executada com sucesso',
                integrity_report: integrityCheck,
                timestamp: new Date().toISOString()
            });

        } catch (error) {
            console.error('‚ùå [CONTROLLER] Erro ao for√ßar atualiza√ß√£o:', error);
            return ResponseHelper.error(res, 'Erro ao executar atualiza√ß√£o de constru√ß√µes', 500);
        }
    }

    /**
     * Gerar resumo das constru√ß√µes
     * @param {Array} constructions - Lista de constru√ß√µes
     * @returns {Object} - Resumo estat√≠stico
     */
    generateConstructionsSummary(constructions) {
        if (!Array.isArray(constructions) || constructions.length === 0) {
            return {
                total: 0,
                by_status: {},
                by_category: {},
                total_invested: 0,
                active_constructions: 0,
                completed_constructions: 0,
                average_progress: 0
            };
        }

        const summary = {
            total: constructions.length,
            by_status: {},
            by_category: {},
            total_invested: 0,
            active_constructions: 0,
            completed_constructions: 0,
            average_progress: 0
        };

        constructions.forEach(construction => {
            const status = construction.status || 'unknown';
            const category = construction.construction_types?.category || 'unknown';
            
            // Contar por status
            summary.by_status[status] = (summary.by_status[status] || 0) + 1;
            
            // Contar por categoria
            summary.by_category[category] = (summary.by_category[category] || 0) + 1;
            
            // Somar investimentos
            summary.total_invested += parseFloat(construction.final_cost || 0);
            
            // Contar ativas e completas
            if (status === 'in_progress' || status === 'bidding') {
                summary.active_constructions++;
            }
            if (status === 'completed') {
                summary.completed_constructions++;
            }
        });

        // Calcular progresso m√©dio das constru√ß√µes ativas
        const activeConstructions = constructions.filter(c => 
            c.status === 'in_progress' || c.status === 'bidding'
        );
        
        if (activeConstructions.length > 0) {
            const totalProgress = activeConstructions.reduce((sum, c) => 
                sum + (c.progress_percentage || 0), 0
            );
            summary.average_progress = Math.round((totalProgress / activeConstructions.length) * 100) / 100;
        }

        return summary;
    }
}

module.exports = ConstructionController;